## oop패키지의 RestaurantChain은 왜 객체지향적?
1. 객체가 어떤 메시지(필요한 값이나 목표)를 전달할 수 있게 됨.
2. 객체가 어떤 책임을 지게 됨.
3. 객체는 어떤 책임을 처리하는 방법을 스스로 알고있다.

=> 비즈니스 로직을 객체가 처리한다. Store, Order, Food 각 객체가 자기가 가지고 있는 필드에 대한 값을 스스로 처리.

-> 행동과 데이터가 한 곳에 잘 응집됐다. => 응집도가 높다!!!

객체지향은 가독성 < <b>책임</b>
각자의 객체는 협력 객체가 '어떻게' 일하는 지 신경 x, 제대로 했는지만 신경 씀.

-> 캡슐화. -> 협력 객체들이  계약을 제대로 지키는가? 책임을 다하는가? -> 검사하는 것 => 테스트 코드

```
절차지향 : 책임을 프로시저로 나누고 프로시저에 할당
객체지향 : 책임을 객체로 나누고 객체에 할당
```

단순히 <u>책임을 객체에 할당한다.</u>이 한 마디로 객체지향을 설명할 수 있나? -> x, 조금 더 설명이 필요하다.
- C언어도 구체를 만들고 함수 포인터로 구조체에 함수를 넣으면 구조체 단위로 책임을 할당 가능하기에


### Caculable 인터페이스(역할)의 구현
여러 객체들을 역할을 구현하여서 역할에 의존하도록 변경-> 추상화의 원리

=> C언어의 구조체와의 차이점. -> 다형성
- c언어의 구조체의 원래 목적 : 데이터를 한 곳에 모으는 것. 추상화를 지원하기 위해 만들어진 것 x

=> 구현과 역할을 분리, 역할에 책임을 할당 - 객체지향에서 정말 중요

~~~
역할을 이용해서 통신 -> 실제 객체가 어떤 객체인지 신경x, 내가 부탁한 책임과 역할만 할 수 있으면 된다.
=> 새로운 요구사항이 추가? 그 역할을 다하는 새로운 구현체만 만들면 됨.
~~~
### 새로운 구현체 BrandProduct추가해보자

Order에 아래와 같이 필드를 추가
~~~
private List<BrandProduct> brandProducts;
~~~
-> 이건 결국 Caculable을 구현한 건데
~~~
private List<Calculable> foods;
private List<BrandProduct> brandProducts;
~~~
굳이 이렇게 분리? 아래와 같이 변경
~~~
private List<Calculable> items;
~~~
