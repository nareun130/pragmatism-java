# 4 SOLID

1. 단일 책임 원칙(SRP : Single Responsibility Principle)
2. 개방 폐쇄 원칙 (OCP : Open-Closed Principle)
3. 리스코프 치환 원칙 (LSP : Liskov Subsitution Principle)
4. 인터페이스 분리 원칙 (ISP : Interface Segergation Principle)
5. 의존성 역전 원칙 (DIP : Dependency Iversion Principle)

이 원칙들의 목표 : 소프트웨어의 유지보수성과 확장성을 높이기 위해

-> 유지보수성을 높인다는 것은?
~~~
1. 영향범위 : 코드 변경으로 인한 영향 범위가 어떻게 되는가?
2. 의존성 : 소프트웨어의 의존성 관리가 제대로 이뤄지는가?
3. 확장성 : 쉽게 확장 가능한가?
~~~

## 1. 단일 책임 원칙
~~~
클래스에는 단 하나의 책임만 있어야 한다.
-> 특정 역할을 달성하는 데만 집중할 수 있도록
-> 변경으로 인한 영향 범위를 최소화 하는 것
=> 클래스를 변경해야 할 이유는 단 하나여야 한다.
~~~
<i>외부의 변경요청에도 소프트웨어의 <b>항상성</b>을 유지하는 것이 이 원칙의 목적</i>

### 책임이란?
Developer 클래스는 단일책임 원칙을 위배하는 가?

-> 중심을 둬야 할 것은 액터(actor) => 책임은 액터에 대한 책임.
- 어떤 모듈이나 클래스가 담당하는 액터가 혼자면 -> 단일 책임 원칙을 지키고 있음
- 어떤 모듈이나 클래스가 담당하는 액터가 여럿 -> 단일 책임 원칙을 위반

=> 단일 책임원칙을 이해 -> 시스템에 존재하는 액터를 먼저 이해.
- 클래스를 변경해야 할 단 하나의 이유 : 유일한 액터의 요구사항이 변경 될 때(버그나 시스템 성능 개선을 제외)

~~~
단일 책임 원칙의 목표
1. 클래스 변경됐을 때 영향을 받는 액터는 하나
2. 클래스를 변경할 이유는 유일한 액터의 요구사항이 변경될 때
~~~

## 2. 개방 폐쇄 원칙
~~~
확장에는 열려 있고, 변경에는 닫혀 있어야 한다.
-> 기존 코드를 수정x, 확장 가능한 시스템을 만드는 것 
=> 최고의 전략 : 기존 코드를 아예 건드리지 않는 것

개방 폐쇄의 목표
확장 하기 쉬우면서 변경으로 인한 영향 범위를 최소화 하는 것 -> 소프트 웨어 설계에서 매우 중요
- 예시) oop/RestaurantChain의 Order를 참고
=> 코드를 추상화된 역할에 의존하게 만듦으로써 달성 가능(이후 의존성에서 좀 더 살펴볼것)
~~~

## 3. 리스코프 치환 원칙
~~~
기존 클래스의 계약을 파생 클래스가 제대로 치환할 수 있는지 확인하라
-> 파생 클래스가 기본 클래스의 모든 동작을 완전 대체 가능해야한다.
~~~
-> 기존 클래스의 작성 의도를 파악 -> 직접 물어본다? (좋은 방법은x)

=> 초기 코드 작성자가 생각하는 모든 의도를 테스트 코드로 만들어 두는 것
- 기본 클래스로 작성된 테스트에 파생 클래스를 추가해 테스트도 가능
- 인터페이스는 계약, 테스트는 계약 명세

## 4. 인터페이스 분리 원칙
~~~
클라이언트가 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다.
-> 클래스가 자신에게 필요하지 않은 인터페이스의 메서드를 구현하거나 의존하지 않아야 한다.
~~~
-> 하나의 인터페이스로 모든 것을 해결하려할 때 위배. -단일 책임 원칙과도 관련

범용성을 갖춘 하나의 인터페이스를 생성하기 보다 다수의 특화된 인터페이스를 만드는 것이 낫다.
- 통합된 인터페이스는 인터페이스의 역할을 두루뭉술하게 만들어 버림.
-> 인터페이스 분리가 제대로 지켜지지 않은 코드는 단일 책임 원칙도 위배하고 있을 확률이 높음.

### 의문점
인터페이스를 통합 -> 응집도를 추구하는 것 아닌가? 
- 그럴 수도 있지만, 이것이 항상 응집력이 높아지는 결과로 이어지는 것 x
- 응집도 : '유사한 코드를 한곳에 모은다'에서 끝나는 것 x

~~~
응집도는 다양한 종류
기능적 > 순차적 > 통신적 > 절차적 > 논리적  
'유사한 코드를 한곳에 모은다.' : 논리적 응집도를 추구
-> 다른 종류의 응집도 보다 낮은 수준의 응집도를 추구하는 결과
~~~

=> 인터페이스분리 원칙이 추구하는 것은 무엇인가??
- 역할과 책임을 분리하고 역할을 세세하게 나누라는 의미 -> <b>기능적 응집도</b>를 추구한다.
### 인터페이스와 코드의 재사용성
인터페이스를 이용해 코드의 재사용성을 높인다. 

-> 인터페이스 자체의 재사용성을 높인다(x), <b>인터페이스를 사용하는 코드</b>의 재사용성을 높이는 것
- 인터페이스를 사용하는 코드는 구현에 의존x, 바뀌지 않는 비즈니스 로직을 여러 곳에서 재사용 가능 

## 5 의존성 역전 원칙
~~~
구체화가 아닌 추상화에 의존해야 한다.
1. 고수준 모듈은 추상화에 의존해야 한다.
2. 고수준 모듈이 저수준 모듈에 의존해서는 안 된다.
3. 저수준 모듈은 추상화를 구현해야 한다.
~~~

## 의존성
의존(= 결합) : 다른 객체나 함수를 사용하는 상태
- 매개변수로 다른 클래스를 사용하거나
- 참조변수로 다른 클래스를 사용하거나
- 다른 클래스나 인터페이스를 구현하거나

사용하기만 해도 의존하는 것. 

-> 의존이야말로 소프트웨어 설계의 핵심

결합도 = 의존성
- 일반적으로 소프트웨어에서는 결합도가 약하면 약할수록 좋다고 평가

-> 의존성과 결합도를 낮추는 방법?
- 대표적인 게 의존성 주입

### 의존성 주입
단지 필요한 의존성을 외부에서 넣어주는(주입) 것
~~~
의존성 주입 - 의존성 자체를 제거x, 의존성을 약화
의존성 자체를 완전히 제거하는 것은 불가능
- 애초에 객체지향 소프트웨어는 개체와 시스템의 협력
~~~
~~~
new 사용을 자제하라
-> new 사용 : 추상 타입과 관계없이 고정된 객체를 사용하겠다는 의미.
ex) Meet이라는 추상 타입에 new Beef()로 고정된 객체를 사용하는 경우.
=> 객체에 의존하는 것을 피하고 구현 객체가 인스턴스화 되는 시점을 최대한 뒤로 미루어라.
~~~

### 의존성 역전
'대부분의 소프트웨어 문제는 의존성 역전으로 해결이 가능하다.'
- 의존성 주입 != 의존성 역전
~~~
Restaurant 클래스가 HamburgerChef를 사용한다.
- Restaurant -> HamburgerChef (Restaurant가 HamburgerChef에 의존)
Chef라는 인터페이스를 만들고 Restaurant가 Chef를 의존하게 만들어 버림.
- Restaurant -> Chef <- HamburgerChef

=> 화살표의 방향이 바뀌어 버림. (의존을 당하던 객체(HamburgerChef)가 의존을 하는 객체로 바뀜)
-> 의존성 전이라는 특징에 의해
~~~
의존성 역전 -> 코드가 추상에 의존하는 형태로 바뀜.

=> <i>세부사항에 의존하지 않고 정책에 의존하도록 코드를 작성하라.</i>

의존성 역전을 통해 생긴 경계 -> 모듈의 경계
<i>시스템 설계 시 상위 모듈은 하위 모듈에 의존하면 안된다.</i>
~~~
1. 상위 모듈은 하위 모듈에 의존해서는 안 된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
2. 추상화는 세부 사항에 의존해서는 안된다. 세부 사항이 추상화에 의존해야 한다.
=> 구현보다 추상에 의존해라
~~~

<i>클린아키텍처 : java 같은 정적 타입 언어에서는 import 구문에 오직 인터페이스나 추상 클래스 같은 추상 선언만이 있어야 한다.</i>

## 의존성과 스프링
- 스프링은 의존성 주입을 지원하는 프레임워크인가?
- 스프링은 의존성 역전 원칙을 지원하는 프레임 워크인가?

=> 스프링은 의존성 주입을 지원하는 프레임워크지만, 의존성 역전 원칙을 지원하는 프레임 워크는 아님. 의존성 역전 원칙은 설계의 영역.

## 왜 이렇게 의존성을 강조할까?
유지보수성 판단
~~~
1. 영향범위 : 코드 변경으로 인한 영향 범위가 어떻게 되는가?
-> 영향 범위에 문제가 있으면 응집도를 높이고, 적절히 모듈화 => 단일 책임 원칙을 준수하는 코드를 만든다.
2. 의존성 : 소프트웨어의 의존성 관리가 제대로 이뤄지는가?
-> 의존성에 문제가 있다면 의존성 주입과 의존성 역전 원칙 등을 적용해 약한 의존 관계를 만든다.
3. 확장성 : 쉽게 확장 가능한가?
-> 확장성에 문제가 있다면 의존성 역전 원칙을 이용해 개방 폐쇄 원칙을 준수하는 코드로 반든다.
~~~
<i>소프트웨어를 설계를 잘한다. -> 코드를 변경하거나 확장할 때 영향 받는 범위를 최소화 해야 한다. => 의존성을 잘 다뤄야 한다.</i>

의존성을 잘 관리한다.
- 의존성 : 다른 객체나 시스템을 사용한다.

=> '불필요한 의존성을 줄인다.'라는 목표를 포함. 없애는 것이 목표x, '의존성을 끊는 것'이 목표
- 의존성은 화살표의 역방향으로 전이 된다.
- 의존성 역전을 통해 경계를 만든다. -> 변경으로 인한 영향 범위를 축소하는 것.

<i>소프트웨어 설계는 복잡도와의 싸움. 스파게티 코드의 원인의 핵심. => 의존 관계 관리가 제대로 안 되어서</i>

~~~
 순환 참조를 만들지 마라.

 A -> B <-> C <- D <- E(B와 C의 순환 참조)
 

 - 여기서 B의 변경 -> A,C,D,E 영향
 - 혹은 C의 변경 -> A, B, D, E 
 ~~~
 
순환 참조는 사실상 같은 컴포넌트

~> B, C의 변경을 통해 영향받는 컴포넌트의 범위가 같아졌기에

순환 참조 -> 복잡한 의존성 그래프 유도, 의존성 전이 범위를 넓힌다.

순환 참조는 양방향, 사이클에서 생긴다. => 단방향으로 만들어야 한다.

## SOID와 객체지향
~~~
SOLID한 코드는 객체지향적인 코드다.
~~~
->  얼추 맞지만 조금 다르다.
- SOLID원칙이 추구하는 것은 객체지향 '설계' -> 변경에 유연하고 확장가능 코드를 만드는 것이 초점
- SOLID는 객체지향 방법론 중 하나. -> <b>응집도를 높이고 의존성을 낮추고</b>
- 객체지향의 핵심 : 역할, 책임, 협력
~~~
SOLID 추구 -> 객체지향 (x)

소프트웨어는 복잡계 -> 요구사항과 100%일치하는 해결책은 존재x
객체지향의 본질인 역할, 책임, 협력을 제대로 이해하고 적절한 구현을 함께 고려
SOLID를 외우기 보다  SOLID가 해결하려 했던 문제와 추구했던 목표가 무엇이었는지 고심하자
=> 높은 응집도와 낮은 결합도
~~~

## 디자인패턴
디자인 패턴을 적용하는 것에 포커즈(X), 의존 관계를 고민
- 모듈의 경계를 분리, 의존 관계를 정리, 순환 참조를 없애려 노력 -> 디자인 패턴이 적용된다.

<i>디자인 패턴이 어떤 상황에서 어떤 문제를 어떻게 해결하는지 이해하는 것이 효율적인 학습 방법</i>
- 도식화된 생김새를 외우기 < 의존 그래프 파악, 변경으로 인해 영향을 받는 범위가 어디까지 인지 파악
- 패턴은 문제 인식, 해결 과정, 해결 방법의 정리 -> 문제를 맞닥 뜨렸을 때 중간중간의 해결 방법만 알고 있으면 자연스럽게 패턴은 따라옴. 억지로 암기 x

=> 패턴이 무조건 최선 x, 중요한 것은 패턴에 담긴 '문제 인식', '해결 과정', '해결 방법'
