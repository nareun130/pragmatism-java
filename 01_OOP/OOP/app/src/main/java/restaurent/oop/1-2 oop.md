# 1-2 객체지향
## oop패키지의 RestaurantChain은 왜 객체지향적?
1. 객체가 어떤 메시지(필요한 값이나 목표)를 전달할 수 있게 됨.
2. 객체가 어떤 책임을 지게 됨.
3. 객체는 어떤 책임을 처리하는 방법을 스스로 알고있다.

=> 비즈니스 로직을 객체가 처리한다. Store, Order, Food 각 객체가 자기가 가지고 있는 필드에 대한 값을 스스로 처리.

-> 행동과 데이터가 한 곳에 잘 응집됐다. => 응집도가 높다!!!

객체지향은 가독성 < <b>책임</b>
각자의 객체는 협력 객체가 '어떻게' 일하는 지 신경 x, 제대로 했는지만 신경 씀.

-> 캡슐화. -> 협력 객체들이  계약을 제대로 지키는가? 책임을 다하는가? -> 검사하는 것 => 테스트 코드

```
절차지향 : 책임을 프로시저로 나누고 프로시저에 할당
객체지향 : 책임을 객체로 나누고 객체에 할당
```

단순히 <u>책임을 객체에 할당한다.</u>이 한 마디로 객체지향을 설명할 수 있나? -> x, 조금 더 설명이 필요하다.
- C언어도 구체를 만들고 함수 포인터로 구조체에 함수를 넣으면 구조체 단위로 책임을 할당 가능하기에


### Caculable 인터페이스(역할)의 구현
여러 객체들을 역할을 구현하여서 역할에 의존하도록 변경-> 추상화의 원리

=> C언어의 구조체와의 차이점. -> 다형성
- c언어의 구조체의 원래 목적 : 데이터를 한 곳에 모으는 것. 추상화를 지원하기 위해 만들어진 것 x

=> 구현과 역할을 분리, 역할에 책임을 할당 - 객체지향에서 정말 중요

~~~
역할을 이용해서 통신 -> 실제 객체가 어떤 객체인지 신경x, 내가 부탁한 책임과 역할만 할 수 있으면 된다.
=> 새로운 요구사항이 추가? 그 역할을 다하는 새로운 구현체만 만들면 됨.
~~~
### 새로운 구현체 BrandProduct추가해보자

Order에 아래와 같이 필드를 추가
~~~
private List<BrandProduct> brandProducts;
~~~
-> 이건 결국 Caculable을 구현한 건데
~~~
private List<Calculable> foods;
private List<BrandProduct> brandProducts;
~~~
굳이 이렇게 분리? 아래와 같이 변경
~~~
private List<Calculable> items;
~~~

=> 구체적인 것(클래스)이 아닌 추상적인 것(역할, 인터페이스)에 집중할 때 유연한 설계를 얻을 수 있다.

## 객체지향의 본질
1. 역할
2. 책임
3. 협력

추상화, 다형성, 상속, 캡슐화 -> 객체지향의 대표적인 기능적 특징 o, 객체지향의 본질x

객체지향의 객체는 실세계를 반영하지x, 자아를 가진 객체들이 협력하는 방식으로 개발되는 것에 가깝다.
- 이상한 나라를 창조하라

## 절자치향이 객체지향에 비해 뒤떨어진 방법? NO
소규모 프로젝트의 경우 절차지향이 훨씬 빠르고 효율적일 수 있다. 객체지향을 하면서도 모든 코드가 객체지향적일 수는 없다. -> 그때그때 정해서!
