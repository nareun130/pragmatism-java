# 2-1 VO (값 객체)
값 객체 - 객체면서 동시에 값
-> 값?? 이 값을 소프트웨어 관점에서 어떻게 해석할까?
1. 불변성
- 숫자 1은 영원한 1
2. 동등성
- 숫자 1은 어느 위치나 시간에 상관없이 숫자 1
3. 자가검증
- 숫자 1은 그 자체로 올바른 숫자. '1은 사실 1.01이 아닐까?' 같은 고민이 필요 x

## 1. 불변성
'변하지 않는다.' -> 시스템의 복잡도를 획기적으로 낮추는 개념.

=> 소프트웨어는 불확실한 요소가 많음 -> 확실한 영역을 최대한 많이 만든다.
- VO 선언된 모든 멤버변수는 final로 선언  ~> 모든 멤버 변수가 final로 선언 -> VO (x) 
- final로 선언하더라도 멤버변수가 원시타입x, 참조타입이면 불변성 보장x 
~~~
참조 타입의 멤버변수가 final로 선언x -> 불변성이 깨질 수 있다.
~~~

### 불변성의 조건
1. 모든 멤버변수가 final
2. 모든 함수가 순수 함수
    - 순수함수 : 입력값 동일 -> 반환값 동일
=> 이 둘만 만족 -> 불변 ? (X)
- 상속된 클래스의 멤버변수가 불변이 아닐 경우가 있다.

-> 이렇듯 참조타입의 멤버변수, 상속된 클래스의 멤버변수에 의해 불변성은 쉽게 깨질 수 있다.

=> VO 클래스는 아예 final 클래스로 선언 -> 불변성을 유지
- 불변성이 지닌 가치? -> 객체를 신뢰 => 다른 객체와 협력하는 과정에서 예측 가능한 방식으로 동작하게끔

### 예측 불가능한 동작? 
AccountInfo의 setMileage와 getLevel을 서로다른 스레드에서 호출 한다 생각!
서로다른 시점에서 두 스레드가 getLevel과 setMileage를 호출 하면, 이상한 결과가 나올 수 있다.

-> 이 문제를 어떻게 해결 할까?

=> setter를 제거하고 새로운 객체를 반환하도록

<i>불확실성을 없애는 것은 불가능, 하지만 최대한 줄일 수 있도록</i>

## 2. 동등성
어떤 객체가 값이고 상태가 모두 같다? -> 같은 객체
- equals, hashCode를 오버라이딩


=> 롬복의 @Value를 통해 값객체를 편하게 만들 수 있다.
1. equals & hashCode가 객체의 상태에 따라 비교하는 메서드로 자동생성
2. 멤버변수가 final로 선언
3. 클래스가 final로 선언

### 동등성 vs 식별자
VO에는 식별자를 넣어서는 안된다. => 예측 불가능성이 다시 생겨버림.
~~~
동등성과 식별자의 의미상 충돌이 생김.
동등성 : 객체의 값, 상태가 모두 같을 때 vs 식별자 : 객체를 식별

AccountInfo account1 = new AccountInfo(1, 20_000);
AccountInfo account2 = account1.withMileage(70_000);
System.out.println(account1 == account2); // false
~~~

## 3. 자가 검증
자가검증 : 클래스 스스로 상태가 유효한지 검증
~~~
※ 한 번 생성된 VO의 멤버변수에는 이상한 값이 있을 수 없다.
~~~

자가검증이 완벽한 객체 -> 상태검증을 위해 if-else, try-catch문을 사용할 필요 x

=> 자가 검증은 VO에서만 사용가능 x, 자가 검증이 완료된 객체는 사용하기가 매우 편리

# 우리가 고려해야할 것
실제로 개발 시 중요한 것 -> 이 객체가 VO냐 아니냐 x, VO의 목적을 고민해보는 과정
- 신뢰할 수 있는 객체를 어떻게 만들까?
- 어떤 값을 불변으로 ㅁ나들까?
- 어디까지 값을 보장해야 하나

<i>VO를 추구하기보다 불변성, 동등성, 자가 검증, 신뢰할 수 있는 객체를 추구해야 한다.</i>
