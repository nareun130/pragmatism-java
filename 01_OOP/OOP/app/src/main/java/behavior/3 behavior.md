# 3 행동
객체는 단순한 데이터 덩어리x, 자아를 가진 것 처럼 동작해야 한다.
-> 어떻게? TDA원칙을 적용 하는 것
- 수동적인 객체 -> 능동적인 객체
- 객체가 이미 존재해야한다는 것을 전제

=> 객체를 설계하는 단계에서는 어떻게?
데이터 위주 < 행동위주

객체를 구분 짓는 요인은 데이터가 아닌 <b>행동</b>
- <u>데이터가 객체를 결정x, 행동이 객체를 결정한다.</u>
~~~
행동을 고민 -> 역할을 고민 -> 역할이 모여 객체를 정의
~~~

## 1. 덕 타이핑
객체지향은 행동을 강조 -> 덕 타이핑
~~~
덕 텍스트 : 만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다.
~~~
=> 행동이 같으면 같은 객체

## 2. 행동과 구현
- CarEx2 참조

행동의 구현을 고민 -> 어떤 값을 가지고 있는지 고민하게 됨. 
- 반가운 상황x -> 다시 데이터 위주의 사고로 돌아갔기 때문

=> 구현을 고민해서 발생한 일. 어떻게 구현에 구애받지 않고 행동만 고민? 바로 <b>인터페이스</b>
~~~
초기 설계 단계에서 상세한 구현은 무시
- 상세 구현은 동료를 믿고 맡기는 것
가장 중요한 것은 인터페이스를 반드시 지키는 것
~~~

## 3. 인터페이스
<i>인터페이스와 행동은 다르다.</i>

행동이 곧 인터페이스 (X)

인터페이스 : 외부에서 어떤 객체에게 행동을 시키고자 할 때 메시지를 보낼 수 있는 창구일 뿐 
- 객체들의 협력을 위한 창구 -> public 메서드

=> 객체 간 결합도를 낮춤. -> 유연성과 확장성 획득

## 4. 행동과 역할

~~~
'자동차 클래스를 만들어 줄 수 있나요?' -> 이 질문은 데이터 위주의 사고를 하도록 유도한 유도 요청
'탈것 클래스를 만들어 줄 수 있나요?' -> 행동 위주로 사고가 가능
~~~
- 자동차 : 실체, 탈것 : 역할 

실체에 집중 -> 데이터 위주의 사고, 역할에 집중 -> 행동위주의 사고
- 실체는 곧 구현

### 우리가 역으로 했어야 하는 질문
'자동차 클래스를 만들어 줄 수 있나요?'를 받았을 때
1. 자동차는 어떤 행동을 하는 객체인가요?
2. 꼭 자동차이어야 하나요?
3. 자동차라는 클래스를 만들어서 달성하려는 목표가 뭐지요?

-> '탑승할 수 있고, 달릴 수 있으면 좋겠네요.'

=> 아, 클라이언트가 진짜 원하는 것은 '탈 것'이구나!
- Vehicle이라는 인터페이스를 만들 수 있음.

<i>구현에 집중한 코드는 확장되는 요구사항에 유연하게 대처x, 역할에 집중 -> 유연한 설계가 가능</i>

<i>행동과 역할에 집중 -> 추상화를 많이 하라.(X), 역할과 추상은 같은 말x</i>

## 5. 메서드
메서드 : 함수의 개념으로는 정의 불가
- 함수 : 같은 입력에 대해 항상 같은 출력을 하는 것

~~~
객체지향에서는 특정한 구현에 의존하는 상황을 피하려 한다.
-> 협력 객체에 어떤 일을 요청할 때 '함수를 실행한다.' 대신 '메시지를 전달한다.'라고 표현
~~~

객체는 협력 객체에 메시지만 보낸다. 어떤 방법(method)으로 일을 어떻게 처리할 지? -> 객체가 결정

=> 메서드를 어떻게 구현할지 집중하는 것은 좋은 방법x
- 메서드 -> 알고리즘에 가까움.(메시지를 어떻게 처리할지) => 결국 구현에 집착. -> 절차지향적 코드

<i>객체지향에서 진짜 중요한 것은 책임을 나누고 메시지를 통해 협력 관계를 구축하는 것</i>

### 명시적 입력, 암묵적 입력

명시적 입력: Math.add(2,3)
- 함수의 매개변수를 통해 직접 전달되는 입력

암묵적 입력 webClient.get(...)
- 매개변수 외에 네트워크 상태와 같은 시스템 바깥의 상태같은 추가적임 입력
- 전역변수나 클래스의 인스턴스 변수를 참조할 때 자주 나타남.

- 암묵적 입력 -> 시스템 복잡도가 증가 => 최대한 암묵적 입력을 줄이기 위해 노력
~~~
객체 - 불변성 -> 불변 객체
함수 - 불변성 -> 순수함수

이런 불변성에 집중해 객체를 만들고 함수를 만드는 방식을 함수형 프로그래밍
~~~