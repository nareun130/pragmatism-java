# 5 순환 참조
순환 참조
- 두 개 이상의 객체나 컴포넌트가 서로를 참조함 -> 의존 관계에 사이클 발생 -> 대표적인 안티패턴 중 하나
~~~
JPA의 양방향 매핑 설명 시 Team-Member 사례를 이용.
-> JPA를 사용 시 순환 참조를 거리낌 없이 만들고 함.
~~~

양방향 매핑은 수많은 순환 참조 사례 중 하나

~~~
TeamService, MemberSerivce를 확인하면 TeamService는 MemberService를 참조하고,
MemberService는 또 TeamService를 참조
-> 사실상 하나의 컴포넌트 => 책임의 구분x, SOLID하지도 않다.
~~~
## 순환 참조의 문제점
### 1. 무한 루프
~~~
CircularEx1을 참고
Team -> Member
Member -> Team
계속 무한 루프 -> 직렬화 불가능
~~~

무한루프는 개발자가 메서드 호출 과정을 신경 쓴다고 해결할 수 있는 문제x

~> 소프트웨어는 복잡계라서 언제, 어디서, 어떤 식으로 작용이 발생할 지 모름.

=>순환 참조를 만들지 않으면 된다.

### 2. 시스템 복잡도
시스템 복잡도를 높인다. -> 의존성 전이 확장과도 비슷하나 좀 더 실무적인 문제
~~~
Member에 소속된 팀의 전체 월급이 얼마인지 알 수있는 메서드를 추가 -> 말이 안됨.
- 팀원이 어떻게 팀 내 전체 구성원의 월급을 알 수 있나
~~~
=> 의미상 말이 안되는 코드는 컴파일 타임에 아예 생성x
- 시스템 복잡도가 증가 -> 코드의 복잡도 증가뿐만 아닌, 개발자가 겪는 논리적 혼란도 포함

Team - Member 간의 순환 참조를 어떻게 제거 할까?
1. Member의 식별자를 대신 배치 -> 양방향 참조를 제거
2. 상위 객체에 있던 하위 객체에 대한 참조를 제거 -> 순환 참조를 제거

~~~
'접근 경로가 많다.' -> 의존 관계가 복잡하게 얽혀있다.
=> 가능 한 도메인 모델들에 단일 진입점을 만들어서 필요한 객체가 있을 때 단방향으로 접근하도록 만든다.
~~~

## 순환 참조의 해결
가장 확실한 것은 순환 참조 자체를 만들지 않는 것
### 1. 불필요한 참조를 제거
양방향 참조가 꼭 필요한지 재고해보는 것
~~~
TeamJpaEntity 클래스에 꼭 
List<MemberJpaEntity> members가 필요?
- jpa를 통해 불러올 떄마다 n+1 문제가 발생할 수 있는 부담도 있음.
~~~
-> members를 제거, MemberRepositroy.findByTeamId(teamId) 이렇게 팀원 목록을 가져오면 된다.

### 2. 간접 참조 활용
~~~
TeamJpaEntity에 members를 존재 시키고
MemberJpaEntity에 TeamJpaEntity 참조 대신 private long myTeamId를 선언
-> 불필요한 참조를 제거한다는 방법과 유사
~~~

### 의문점
이런 방식을 통해 객체간의 불필요한 의존 관계를 제거한다.

~> 'SQL 쿼리가 여러 번 발생할 수 있지 않나?'

-> 맞다. 간접 참조로 인해 몇 줄 SQL쿼리가 추가될 수 있다.
- 짧은 쿼리 몇 줄 추가는 그렇게 큰 문제x
- 식별자의 기본키 인덱싱, 시스템 곳곳의 다양한 캐싱 장치
- 복잡한 참조 관계 -> DB에서 복잡한 쿼리가 실행 -> 캐싱 장치를 활용하기 어려워짐.

=> 복잡하고 긴 쿼리 한 번보다 오히려 짧은 쿼리를 여러 번 사용하는 것이 더 빠를 수 있다.
~~~
개발자들은 '한 방 쿼리'등을 만들어 문제를 해결하려 한다. 오히려 약간 중복이 발생하더라도 단순한 로직을 여러번 사용 or 짧은 쿼리 여러 번 실행이 유리할 수 있다. 
=> 단순함을 전제로 시스템을 최적화해야 한다.
~~~

### 3. 공통 컴포넌트 분리
~~~
A <-> B
(순환되는 코드 추출)
=> A -> C <- B
~~~
양쪽 서비스에 있던 공통 기능을 하나의 컴포넌트로 분리 

-> 대부분의 컴포넌트간 순환 참조 문제를 해결할 수 있음.

### 4. 이벤트 기반 시스템
~~~
컴포넌트들이 중앙 큐를 구독하게 함.
각 컴포넌트들은 다른 컴포넌트에 시켜야 할 일이 있으면 큐에 이벤트 발생
이벤트 발행 -> 큐를 구독 하고 이벤트를 자신이 처리해야 하면 읽어 처리하고, 처리하지 않아도 되면 무시
~~~
=> 컴포넌트들이 서로를 상호 참조x, 이벤트와 이벤트 큐에 의존

4번은 최후의 방법, 일단 1,2,3 순서대로 적용 후 마지막에 접근
- 이벤트 기반 시스템은 설계의 근간을 바꾸는 것이라서

## 3. 양방향 매핑
~~~
양방향 매핑이라는 개념이 순환 참조라는 죄악의 면죄부처럼 사용되고 있다.
~~~
JPA에 양방향 매핑이 있다고, 그걸 적극적으로 써도 된다.(X)

~> 순환 참조는 어떻게 해서든 없애는 것이 좋고, 대부분 제거 가능. 순환 참조 사용 시에는 신중을 가해야 하면, 양방향 매핑도 같은 맥락으로 사용 시 신중을 가해야 한다.

-> 양방향 매핑이라고 순환참조가 아닌 것은 아니다.
~~~
양방향 매핑은 도메인 설계를 하다가 '어쩔 수 없이' 나오는 순환 참조 문제에 사용하는 것이 바람직
~~~
JPA는 수단일 뿐이다.
=> 수단인 JPA로 인해 시스템 설계가 영향을 받아서 x
### 양방향 매핑이 모범 사례가 되는 경우?
도메인 객체와 영속성 객체를 분리하는 경우, 도메인 객체는 순환 참조x & 영속성 객체는 쿼리를 쉽게 만들기 위해 양방향 매핑을 사용 가능

### 연관관계의 주인
객체지향에서는 완전한 의미의 양방향 참조가 존재x, 단방향 참조가 양쪽으로 존재할 뿐

RDBMS에는 실제로 양방향 관계가 존재. -> DB상 하나로 표현되는 개념을 객체지향으로 끌고와서 두 개로 표현하려 하니 여러 부작용이 생긴 것.

=> 애초에 순환 참조를 만들지 않으면 연관 관계의 주인이 누군지 신경 쓸 필요 x
## 4. 상위 수준의 참조
순환 참조는 객체 뿐만이 아닌, 패키지 사이나 시스템 수준에서도 발생 가능

-> 잘 만들어진 패키지는 그 자체로 분리해서 새로운 서비스를 만들 수 있을 정도로 독립적
=> 클래스 뿐만 아니라 상위 수준에서 발생하는 순환 참조를 방지하기 위해 주의
<i>순환 참조 자체를 만들지 않는 것 -> 시스템의 독립성과 유지보수성, 확장성을 높이는 길</i>